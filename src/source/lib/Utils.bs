import "pkg:/source/roku_modules/log/LogMixin.brs"
import "pkg:/source/roku_modules/maestro/core/Global.brs"
import "pkg:/source/lib/Types-Polyfill.bs"

namespace sc
  function isUndefined(value as dynamic) as boolean
    return type(value) = "<uninitialized>"
  end function

  function isSubType(value as dynamic, subType as string) as boolean
    return type(value) = "roSGNode" and value.subType() = subType
  end function

  function isInvalid(value as dynamic) as boolean
    return type(value) = "<uninitialized>" or value = invalid
  end function

  function isArray(value as dynamic) as boolean
    return type(value) <> "<uninitialized>" and value <> invalid and GetInterface(value, "ifArray") <> invalid
  end function

  function isAACompatible(value as dynamic) as boolean
    return type(value) <> "<uninitialized>" and value <> invalid and GetInterface(value, "ifAssociativeArray") <> invalid
  end function

  function isString(value as dynamic) as boolean
    return type(value) <> "<uninitialized>" and GetInterface(value, "ifString") <> invalid
  end function

  function isBoolean(value as dynamic) as boolean
    return type(value) <> "<uninitialized>" and GetInterface(value, "ifBoolean") <> invalid
  end function

  function isFunction(value as dynamic) as boolean
    return type(value) = "Function" or type(value) = "roFunction"
  end function

  function isInteger(value as dynamic) as boolean
    return type(value) <> "<uninitialized>" and GetInterface(value, "ifInt") <> invalid
  end function

  function isDouble(value as dynamic) as boolean
    return type(value) <> "<uninitialized>" and GetInterface(value, "ifDouble") <> invalid
  end function

  function isNumber(value as dynamic) as boolean
    return type(value) <> "<uninitialized>" and (GetInterface(value, "ifFloat") <> invalid or GetInterface(value, "ifInt") <> invalid or GetInterface(value, "ifDouble") <> invalid)
  end function

  function isFloat(value as dynamic) as boolean
    return type(value) <> "<uninitialized>" and GetInterface(value, "ifFloat") <> invalid
  end function

  function isPoint(value as dynamic) as boolean
    return sc.isArray(value) and value.count() = 2
  end function

  function isRectangle(value as dynamic) as boolean
    return sc.isArray(value) and value.count() = 4
  end function

  function isClass(value as dynamic) as boolean
    return sc.isAACompatible(value) and sc.isString(value.__classname)
  end function

  function isPointEqual(value as dynamic, otherValue as dynamic) as boolean
    return sc.isPoint(value) and sc.isPoint(otherValue) and value[0] = otherValue[0] and value[1] = otherValue[1]
  end function

  function dv(view as dynamic) as string
    if type(view) = "roSGNode"
      return view.subtype() + "." + view.id
    else
      return "#INVALID#"
    end if
  end function

  ' /**
  '  * @member callAAFunc
  '  * @memberof module:Utils
  '  * @instance
  '  * @function
  '  * @description allows for easy calling of a method with variargs, on an aa
  '  * @param {class} target
  '  * @param {funcName} name of func to call
  '  * @param {Any} p1 param 1, can leave blank to skip
  '  * @param {Any} p2 param 2, can leave blank to skip
  '  * @param {Any} p3 param 3, can leave blank to skip
  '  * @returns {any} whatever the func returns, or invald if not found
  '  */
  function callAAFunc(target as sc.types.node, funcName as string, p1 = "#M_NONE#" as dynamic, p2 = "#M_NONE#" as dynamic, p3 = "#M_NONE#" as dynamic) as dynamic

    if target <> invalid
      if sc.isFunction(target[funcName])
        if not sc.isString(p3) or p3 <> "#M_NONE#"
          return target[funcName](p1, p2, p3)
        else if not sc.isString(p2) or p2 <> "#M_NONE#"
          return target[funcName](p1, p2)
        else if not sc.isString(p1) or p1 <> "#M_NONE#"
          return target[funcName](p1)
        else
          return target[funcName]()
        end if
      else
        m.log.error("target did not have function named", funcName)
      end if
    else
      'm.log.error("tried to call AAFunc; with empty target")
    end if

    return invalid
  end function

  function apply(func as dynamic, args = [] as sc.types.array, target = invalid as sc.types.assocarray, warnIfNoFunction = true as boolean) as dynamic
    if not sc.isArray(args)
      m.log.error("apply expects an array of args")
      return invalid
    end if

    count = args.count()
    if count > 4
      m.log.error("apply only supports up to 4 params")
      return invalid
    end if

    if target <> invalid
      if sc.isFunction(func)
        target.__cb = func
        count = args.count()
        if count = 0
          return target.__cb()
        else if count = 1
          return target.__cb(args[0])
        else if count = 2
          return target.__cb(args[0], args[1])
        else if count = 3
          return target.__cb(args[0], args[1], args[2])
        else if count = 4
          return target.__cb(args[0], args[1], args[2], args[3])
        end if
        return invalid
      end if
      if type(target) = "roSGNode"
        return target@._apply(func, args, warnIfNoFunction)
      end if
      if not sc.isFunction(target[func])
        if warnIfNoFunction
          m.log.error("target did not have function ", func)
        end if
        return invalid
      end if

      if count = 0
        return target[func]()
      else if count = 1
        return target[func](args[0])
      else if count = 2
        return target[func](args[0], args[1])
      else if count = 3
        return target[func](args[0], args[1], args[2])
      else if count = 4
        return target[func](args[0], args[1], args[2], args[3])
      end if
    else
      if not sc.isFunction(func)
        'm.log.error("tried to apply to out of scope function")
        return invalid
      end if

      if count = 0
        return func()
      else if count = 1
        return func(args[0])
      else if count = 2
        return func(args[0], args[1])
      else if count = 3
        return func(args[0], args[1], args[2])
      else if count = 4
        return func(args[0], args[1], args[2], args[3])
      end if
    end if
    return invalid
  end function

  function removeDuplicateKeys(aa = invalid as sc.types.assocarray, otherAA = invalid as sc.types.assocarray)
    if otherAA <> invalid and aa <> invalid

      for each key in otherAA
        if aa.doesExist(key) and formatJson(aa[key]) = formatJson(otherAA[key])
          aa.delete(key)
        end if
      end for

    end if

    return aa
  end function

  ' /**
  '  * @member getPath
  '  * @memberof module:Utils
  '  * @instance
  '  * @function
  '  * @description gets content field from array. This variation has a slower implementation that supports array lookup
  '  * @param {assocarray} content - node/aa to look up on
  '  * @param {string} field - path to field, with "items.2.path.syntax",
  '  * @returns {any} value if found, or default value
  '  */
  function getPath(content as object, path = invalid as string, default = invalid as dynamic, disableIndexing = false as boolean) as dynamic
    part = invalid

    if path <> invalid
      parts = path.split(".")
      numParts = parts.count()
      i = 0

      part = content
      while i < numParts and part <> invalid
        if not disableIndexing and (parts[i] = "0" or (parts[i].toInt() <> 0 and parts[i].toInt().toStr() = parts[i]))
          if sc.isArray(part)
            part = part[parts[i].toInt()]
          else if type(part) = "roAssociativeArray"
            part = part[parts[i]]
          else if type(part) = "roSGNode"
            if part.isSubtype("sc_Array") or part.subType() = "sc_Array"
              part = part.callFunc("get", parts[i].toInt())
            else
              part = part.getChild(parts[i].toInt())
            end if
          else
            part = invalid
          end if
        else
          if sc.isAACompatible(part)
            part = part[parts[i]]
          else
            part = invalid
          end if
        end if
        i++
      end while
    else if not sc.isInvalid(content)
      part = content
    end if

    if part <> invalid
      return part
    else
      return default
    end if
  end function

  function getString(content as object, path = invalid as string, default = "" as dynamic, disableIndexing = false as boolean) as dynamic
    value = sc.getPath(content, path, invalid, disableIndexing)
    if sc.isString(value)
      return value
    end if
    return default
  end function

  function getInteger(content as object, path = invalid as string, default = 0 as dynamic, disableIndexing = false as boolean) as dynamic
    value = sc.getPath(content, path, invalid, disableIndexing)
    if sc.isInteger(value)
      return value
    end if
    return default
  end function

  function getArray(content as object, path = invalid as string, default = [] as dynamic, disableIndexing = false as boolean) as dynamic
    value = sc.getPath(content, path, invalid, disableIndexing)
    if sc.isArray(value)
      return value
    end if
    return default
  end function

  function getAA(content as object, path = invalid as string, default = {} as dynamic, disableIndexing = false as boolean) as dynamic
    value = sc.getPath(content, path, invalid, disableIndexing)
    if sc.isAACompatible(value)
      return value
    end if
    return default
  end function

  function getFloat(content as object, path = invalid as string, default = 0.0 as dynamic, disableIndexing = false as boolean) as dynamic
    value = sc.getPath(content, path, invalid, disableIndexing)
    if sc.isFloat(value)
      return value
    else if sc.isInteger(value)
      return value * 1.0
    end if
    return default
  end function

  function getBoolean(content as object, path = invalid as string, default = false as dynamic, disableIndexing = false as boolean) as dynamic
    value = sc.getPath(content, path, invalid, disableIndexing)
    if sc.isBoolean(value)
      return value
    end if
    return default
  end function

  function getPoint(content as object, path = invalid as string, default = [0, 0] as dynamic, disableIndexing = false as boolean) as dynamic
    value = sc.getPath(content, path, invalid, disableIndexing)
    if sc.isPoint(value)
      return value
    end if
    return default
  end function

  function getNode(content as object, path = invalid as string, default = invalid as dynamic, disableIndexing = false as boolean) as dynamic
    value = sc.getPath(content, path, invalid, disableIndexing)
    if type(value) = "roSGNode"
      return value
    end if
    return default
  end function

  function getNumber(content as object, path = invalid as string, default = 0 as dynamic, disableIndexing = false as boolean) as dynamic
    value = sc.getPath(content, path, invalid, disableIndexing)
    if sc.isNumber(value)
      return value
    end if
    return default
  end function

  function getAny(content as object, path = invalid as string, default = invalid as dynamic, disableIndexing = false as boolean) as dynamic
    return sc.getPath(content, path, default, disableIndexing)
  end function

  function append(source as sc.types.assocarray, other as sc.types.assocarray)
    if sc.isAACompatible(source) and sc.isAACompatible(other)
      source.append(other)
    end if
    return source
  end function

  ' /**
  '  * @member setPath
  '  * @memberof module:Utils
  '  * @instance
  '  * @function
  '  * @description gets content path from array. This variation has a slower implementation that supports array lookup
  '  * @param {assocarray} content - node/aa to look up on
  '  * @param {string} path - path to path, with "items.2.path.syntax",
  '  * @returns {any} value if found, or default value
  '  */
  function setPath(content as dynamic, path as string, value = invalid as dynamic, insertAAsForMissingValues = true as boolean) as void
    part = invalid
    if path <> invalid
      parts = path.split(".")
      numParts = parts.count() - 1
      i = 0

      if type(content) = "roSGNode" and numParts + 1 > 0
        nodeValue = content[parts[0]]
        data = {}
        data[parts[0]] = nodeValue
        sc.setPath(data, path, value)
        sc.setOrAddNodeField(content, parts[0], data[parts[0]])
        return
      else
        part = content
      end if

      while i < numParts and part <> invalid
        isIndexNumber = parts[i] = "0" or (parts[i].toInt() <> 0 and parts[i].toInt().toStr() = parts[i])
        if isIndexNumber
          index = parts[i].toInt()
        else
          index = parts[i]
        end if

        if sc.isArray(part) and isIndexNumber
          nextPart = part[index]
        else if type(part) = "roSGNode" and isIndexNumber
          nextPart = part.getChild(index)
        else if sc.isAACompatible(part) and not isIndexNumber
          nextPart = part[index]
        else
          nextPart = invalid
        end if

        if nextPart = invalid and insertAAsForMissingValues
          if (not isIndexNumber and sc.isAACompatible(part)) or (isIndexNumber and (sc.isArray(part) or type(part) = "roSGNode"))
            nextPart = {}
            part[index] = nextPart
          else
            'index type mismatch, gonna have to bail
            return
          end if
        end if
        part = nextPart
        i++
      end while

      if part <> invalid and i = numParts
        if sc.isArray(part)
          part[parts[i].toInt()] = value
        else
          part[parts[i]] = value
        end if
      end if
    end if
  end function

  function createPath(path as string, value = invalid as dynamic, insertAAsForMissingValues = true as boolean) as sc.types.assocarray
    content = {}
    sc.setPath(content, path, value)
    return content
  end function

  function setOrAddNodeField(node as sc.types.node, field as string, value = invalid as dynamic)
    if type(node) = "roSGNode"
      if node.doesExist(field)
        node[field] = value
      else
        info = {}
        info[field] = value
        node.addFields(info)
      end if
    else if sc.isAACompatible(node)
      node[field] = value
    else
      m.log.error("tried to set field on invalid node")
    end if
  end function

  function setNodeAAValue(node as sc.types.node, field as string, key as string, value = invalid as dynamic)
    v = node[field]
    if v = invalid
      v = {}
    end if
    v[key] = value
    sc.setOrAddNodeField(node, field, v)
  end function

  function setNodeArrayValue(node as sc.types.node, field as string, index as integer, value = invalid as dynamic)
    v = node[field]
    if v = invalid
      v = []
    end if
    v[index] = value
    sc.setOrAddNodeField(node, field, v)
  end function

  function setOrAddNodeFields(node as sc.types.node, fields as sc.types.array)
    for each field in fields
      sc.setOrAddNodeField(node, field, fields[field])
    end for
  end function

  function getChildAtDepth(node as sc.types.node, depth as integer) as dynamic
    currentDepth = 0

    while node <> invalid and currentDepth < depth
      node = node.getChild(0)
      currentDepth++
    end while

    return node
  end function

  function strToBool(s as string) as boolean
    if s = invalid
      return false
    else
      return (s.toStr() = "true")
    end if
  end function

  function strToInt(s as string) as integer
    if s = invalid
      return 0
    else
      return s.toInt()
    end if
  end function

  function strToLong(value as string) as dynamic
    a& = 0
    if sc.isString(value)
      return a& + parseJson(value)
    end if

    return a&
  end function

  function getIndexOfItem(parent as sc.types.node, item as sc.types.node) as integer
    if item <> invalid
      for index = 0 to parent.getChildCount() - 1
        node = parent.getChild(index)
        if node.id = item.id
          return index
        end if
      end for
    end if
    return -1
  end function

  ' @param {string} nodeType - type of node
  ' @param {node} parent - parent to append created node to
  ' @param {string} id - id of new node
  ' @param {assocarray|array of assocarray} args - if assocarray, fields that are applied to the node on creation, if array of assoarray, will iterate over the fields applying them all
  function createSGNode(nodeType as string, parent = invalid as sc.types.node, id = invalid as string, args = invalid as sc.types.assocarray, isCallingInitialize = true as boolean, mTarget = invalid as sc.types.assocarray) as sc.types.node
    if parent <> invalid
      if type(parent) = "roSGNode" or parent.createChild <> invalid 'allows for mock nodes
        node = parent.createChild(nodeType)
      else
        sc.private.logError("Illegal parent received when calling sc.createSGNode")
        node = createObject("roSGNode", nodeType)
      end if
    else
      node = createObject("roSGNode", nodeType)
    end if

    'MARSHAL PARENT OR ID INTO PARENT INTO ARGS HERE

    if node <> invalid
      if id = invalid
        id = rnd(2147483647).toStr()
      end if

      node.id = id

      if args <> invalid
        if sc.isArray(args) and args.count() > 0
          arrArgs = args[0]
          for i = 1 to args.count() - 1
            arrArgs.append(args[i])
          end for
          args = arrArgs
        end if
        'built in observer support
        if sc.isAACompatible(args.observe)
          for each key in args.observe
            func = invalid
            once = false
            sendMode = "value"
            if sc.isArray(args.observe[key]) and args.observe[key].count() > 0
              func = args.observe[key][0]
              sendMode = args.observe[key][1]
              if sendMode = invalid
                sendMode = "value"
              end if
              once = args.observe[key][2] = true
            else
              func = args.observe[key]
            end if
            if sc.isString(func) and sc.isFunction(m[func])
              func = m[func]
            else
              m.log.error("createSGNode: Could not observe", key, "function", func, "does not exist on m")
            end if
            if mTarget = invalid
              mTarget = m
            end if
            mTarget.observeNodeField(node, key, func, sendMode, once)
          end for
          args.delete("observe")
        end if
        node.setFields(args)
      end if

      if isCallingInitialize and node.isInitialized <> invalid
        node@._initialize()
      end if
    end if

    return node
  end function

  function createNode(nodeType as string) as sc.types.node
    node = createObject(nodeType)
    return node
  end function

  function getFunctionName(value as function) as dynamic
    if sc.isFunction(value)
      return value.toStr().mid(10)
    else
      return invalid
    end if
  end function

  function toggleObserver(target as object, field as string, callbackName = invalid as string)
    if target <> invalid
      if callbackName <> invalid
        target.observeFieldScoped(field, callbackName)
      else
        target.unObserveFieldScoped(field)
      end if
    end if
  end function

  function clamp(number as dynamic, low as dynamic, high as dynamic, wrap = false as boolean) as dynamic
    if number < low
      number = wrap ? high : low
    else if number > high
      number = wrap ? low : high
    end if
    return number
  end function

  function getStackTrace() as string
    text = ""
    try
      throw ""
    catch e
      'bs:disable-next-line
      for i = e.backTrace.count() - 3 to 0 step -1
        'bs:disable-next-line
        item = e.backTrace[i]
        'bs:disable-next-line
        text += item.filename + "(" + item.line_number.toStr().trim() + ")" + chr(10)
      end for
    end try
    return text
  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ punch out methods
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  function getTopM() as dynamic
    return m
  end function

  function getMField(fieldName as string) as dynamic
    return m[fieldName]
  end function

  function getGlobal() as dynamic
    return m.global
  end function

  function getTop() as sc.types.node
    return m.top
  end function

  function getScene() as sc.types.node
    return m.top.getScene()
  end function

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ mis utils
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  function interpolateArray(a as sc.types.array, b as sc.types.array, fraction as float) as sc.types.array
    if a <> invalid and b <> invalid
      return [a[0] + (b[0] - a[0]) * fraction, a[1] + (b[1] - a[1]) * fraction]
    else
      return [0, 0]
    end if
  end function

  function divideNumberToNearest(number as integer, toValue as integer)
    value = fix(number / toValue)
    rest = number mod toValue
    if rest > 0
      value += 1
    end if
    return value
  end function


end namespace

namespace sc.private
  function getMaestroPooledComponent(componentType as string) as object
    componentPool = m.global.__m_componentPool
    if componentPool = invalid
      'bs:disable-next-line
      componentPool = createObject("roSGNode", "sc_ComponentPool")
      componentPool.numberOfComponentsToCreateWhenDry = 5
      componentPool@.prebakeComponents(5, "Timer")
      m.global.addFields({ "__m_componentPool": componentPool })
    end if

    return componentPool@.getComponent(componentType)
  end function

  function releaseMaestroPooledComponent(component as object)
    componentPool = m.global.__m_componentPool
    if componentPool <> invalid
      componentPool@.releaseComponent(component)
    end if
  end function

  function logError(message as string, arg1 = "" as string, arg2 = "" as string, arg3 = "" as string)
    if m.log <> invalid
      m.log.error(message, arg1, arg2, arg3)
    else
      ? "ERROR: " ; message ; " " ; arg1; " " ; arg2; " " ; arg3
    end if
  end function

  function logWarn(message as string, arg1 = "" as string, arg2 = "" as string, arg3 = "" as string)
    if m.log <> invalid
      m.log.warn(message, arg1, arg2, arg3)
    else
      ? "WARN: " ; message ; " " ; arg1; " " ; arg2; " " ; arg3
    end if
  end function

  function getDebugMObject(node as sc.types.assocarray)
    mObject = {}
    for each field in node.items()
      if not sc.isFunction(field.value)
        mObject[field.key] = field.value
      end if
    end for
    return mObject
  end function

end namespace
