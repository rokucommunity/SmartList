import "pkg:/source/roku_modules/log/LogMixin.brs"
import "pkg:/source/core/Utils.bs"
import "pkg:/source/core/Tasks.bs"
import "pkg:/source/view/ViewUtils.bs"

namespace mv.animations.utils
  function colorTo(target as mc.types.node, duration as float, toValue as integer, start = true as boolean, delay = 0 as float) as mv.animations.Fade
    anim = new mv.animations.Color(target, duration, target.opacity, toValue, delay)
    if start
      anim.start()
    end if
    return anim
  end function
  function fadeTo(target as mc.types.node, duration as float, toValue as float, start = true as boolean, delay = 0 as float) as mv.animations.Fade
    anim = new mv.animations.Fade(target, duration, target.opacity, toValue, delay)
    if start
      anim.start()
    end if
    return anim
  end function

  function scaleTo(target as mc.types.node, duration as float, toValue as float, start = true as boolean, delay = 0 as float) as mv.animations.Scale
    anim = new mv.animations.Scale(target, duration, target.scale, toValue, delay)
    if start
      anim.start()
    end if
    return anim
  end function

  function moveTo(target as mc.types.node, duration as float, toValue as float, start = true as boolean, delay = 0 as float) as mv.animations.Move
    anim = new mv.animations.Move(target, duration, target.translation, toValue, delay)
    if start
      anim.start()
    end if
    return anim
  end function

  function animateToJsonViewState(target as mc.types.node, duration as float, toValue as mc.types.assocarray, start = true as boolean, delay = 0 as float) as mv.animations.ViewJson
    anim = new mv.animations.ViewJson(target, duration, target.translation, toValue, delay)
    if start
      anim.start()
    end if
    return anim
  end function

  function getDelta(fromValue as dynamic, toValue as dynamic) as dynamic
    if mc.isPoint(fromValue) and mc.isPoint(toValue)
      return abs((fromValue[0] + fromValue [1]) - (toValue[0] + toValue[1]))
    else if mc.isNumber(fromValue) and mc.isNumber(toValue)
      return abs(fromValue - toValue)
    else
      return 0
    end if
  end function

  function interpolate(a as dynamic, b as dynamic, fraction as float) as dynamic
    if mc.isString(a)
      return mv.animations.utils.interpolateString(a, b, fraction)
    else if mc.isNumber(a)
      return mv.animations.utils.interpolateNumber(a, b, fraction)
    else if mc.isPoint(a)
      return mv.animations.utils.interpolatePoint(a, b, fraction)
    else if mc.isAACompatible(a)
      return mv.animations.utils.interpolateAA(a, b, fraction)
    else if mc.isRectangle(a)
      return mv.animations.utils.interpolateRectangle(a, b, fraction)
    end if
    return invalid
  end function

  function interpolateRectangle(a as mc.types.array, b as mc.types.array, fraction as float) as mc.types.array
    if mc.isRectangle(a) and mc.isRectangle(b)
      return [
        mv.animations.utils.interpolateNumber(a[0], b[0], fraction)
        mv.animations.utils.interpolateNumber(a[1], b[1], fraction)
        mv.animations.utils.interpolateNumber(a[2], b[2], fraction)
        mv.animations.utils.interpolateNumber(a[3], b[3], fraction)
      ]
    else
      return [0, 0, 0, 0]
    end if
  end function

  function interpolatePoint(a as mc.types.array, b as mc.types.array, fraction as float) as mc.types.array
    if mc.isPoint(a) and mc.isPoint(b)
      return [a[0] + (b[0] - a[0]) * fraction, a[1] + (b[1] - a[1]) * fraction]
    else
      return [0, 0]
    end if
  end function

  function interpolateNumber(a as dynamic, b as dynamic, fraction as float) as dynamic
    if a <> invalid and b <> invalid
      return a + (b - a) * fraction
    else
      return 0
    end if
  end function

  function interpolateString(a as string, b as string, fraction as float) as string
    if not mc.isString(a) or not mc.isString(b)
      return ""
    end if
    if len(a) > 1 and left(a, 1) = "#" and len(b) > 1 and left(b, 1) = "#"
      'assume it's a color
      return mv.animations.utils.interpolateHexColors(a, b, fraction)
    end if

    if fraction > 0.5
      return b
    else
      return a
    end if
  end function
  function interpolateAA(a as mc.types.assocarray, b as mc.types.assocarray, fraction as float) as mc.types.assocarray
    if fraction > 0.5
      return b
    else
      return a
    end if
  end function

  function interpolateHexColors(hexColor1 as string, hexColor2 as string, fraction as float)
    c1 = mv.animations.private.convertHexToNumber(hexColor1)
    c2 = mv.animations.private.convertHexToNumber(hexColor2)
    value = mv.animations.private.interpolateColors(c1, c2, fraction)
    return value
  end function
end namespace

namespace mv.animations.private

  'FIXME: this is wip - still not correct
  function convertHexToNumber(hex as string)
    hex = hex.replace("#", "")
    return val(hex, 16)
  end function

  function interpolateColors(color1 as integer, color2 as integer, p as float)
    rgb1 = mv.animations.private.toRGBArray(color1)
    rgb2 = mv.animations.private.toRGBArray(color2)

    q = 1 - p
    ' rr = cInt((rgb1[0] * p) + (rgb2[0] * q))
    ' rg = cInt((rgb1[1] * p) + (rgb2[1] * q))
    ' rb = cInt((rgb1[2] * p) + (rgb2[2] * q))

    rr = cInt(rgb1[0] * p + rgb2[0] * q)
    rg = cInt(rgb1[1] * p + rgb2[1] * q)
    rb = cInt(rgb1[2] * p + rgb2[2] * q)
    return "#" + stri((rr << 16) + (rg << 8) + rb, 16)
  end function

  function toRGBArray(rgb as integer)
    r = rgb >> 16
    g = (rgb >> 8) mod 256
    b = rgb mod 256

    return [r, g, b]
  end function

end namespace

namespace mv.animations
  class AnimationBase
    public node as mc.types.node
    public repeat as boolean
    public control as string
    public fromValue as dynamic
    public toValue as dynamic
    public keyValues as dynamic
    public keys as dynamic
    public keyIndex = 0
    public keyFraction = 0.0
    public keyStartFraction = 0.0
    protected keyEndFraction = 0.0

    protected parentAnimation as mv.animations.AnimationBase
    protected log as log.Logger
    protected target as mc.types.node

    function new(name as string, target as mc.types.node)
      m.log = new log.Logger(name)
      if target = invalid or target.id = invalid or target.id = ""
        m.log.error("target must be a valid node with an id")
      end if
      m.target = target
    end function

    function setControl(control as string)
      m.control = control
      m.node.control = control
    end function

    function start(resume = false as boolean)
      m.keyIndex = 0
      m.node.keyIndex = 0
      m.keyStartFraction = m.keys[m.keyIndex]
      m.keyEndFraction = m.keys[m.keyIndex + 1]
      m.keyFraction = 0
      m.node.keyFraction = 0
      m.setControl(resume ? "resume" : "start")
    end function

    function pause()
      m.setControl("pause")
    end function

    function stop(finish = false as boolean)
      m.setControl(finish ? "finish": "stop")
    end function

    function setRepeat(repeat as boolean)
      m.repeat = repeat
      m.node.repeat = repeat
    end function

    public function destroy()
      if m.node <> invalid
        m.node.getParent().removeChild(m.node)
      end if
    end function

    public function clone()
      'override me
      return invalid
    end function

  end class

  class AbstractAnimation extends mv.animations.AnimationBase
    public target
    public interpolator
    private keys = [0, 1]
    private easeFunction = "linear"
    private delay = 0
    private field = invalid
    public duration = 0.5
    private fractionValueObserver
    public animateFromCurrentValue = false 'if true, the animation will always take the current value, irrespective of from value


    function new(target as mc.types.node, field as string, duration as float, fromValue as dynamic, toValue as dynamic, name = "AbstractAnimation" as string, delay = 0 as float, keys = invalid as mc.types.array)
      super(name, target)
      if field = "#ga_random"
        field = "ga_" + rnd(2147483647).toStr()
        mc.setOrAddNodeField(target, field, 1.0)
      end if
      if target = invalid or target.id = invalid or target.id = ""
        m.log.error("target must be a valid node with an id")
      end if

      m.target = target
      m.duration = duration
      m.fromValue = fromValue
      m.toValue = toValue
      m.field = field
      if keys <> invalid
        m.keys = keys
        m.keyValues = toValue
      end if
      m.createAnimationNode()
      m.setDelay(delay)
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ public api
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    function setEaseFunction(easeFunction as dynamic)
      m.easeFunction = easeFunction
      m.node.easeFunction = easeFunction
    end function

    function setAnimateFromCurrentValue(value as dynamic)
      m.animateFromCurrentValue = value
    end function

    function setKeys(keys as mc.types.array, keyValues as mc.types.array)
      if not mc.isArray(keys)
        m.log.error("received invalid keys", keys)
      end if
      if not mc.isArray(keyValues)
        m.log.error("received invalid keys", keyValues)
      end if
      if keys.count() <> keyValues.count()
        m.log.error("keys have different count from keyValues", keys.count(), keyValues.count())
      end if

      for each value in keyValues
        if not m.isValidValue(value)
          m.log.error("tried to set illegal value in keyValues value: ", value)
        end if
      end for
      m.keys = keys
      m.keyValues = keyValues
      m.interpolator.key = keys
      m.interpolator.keyValue = keyValues
    end function


    protected function isValidValue(toValue as dynamic) as boolean
      return false
    end function

    protected function isValidValues(keyValues as dynamic) as boolean
      return false
    end function

    function syncStartKeys()
      if m.interpolator.keyValue <> invalid and m.interpolator.keyValue.count() > 0
        m.log.info("setting start keys to ")
        mc.setNodeArrayValue(m.interpolator, "keyValue", 0, m.target[m.field])
      end if
    end function

    override function start(resume = false as boolean)
      if m.fractionValueObserver <> invalid
        m.fractionValueObserver.reset()
      end if

      if m.animateFromCurrentValue
        m.syncStartKeys()
      end if
      super.start(resume)
    end function

    function setDuration(duration as float)
      m.duration = duration
      if m.node <> invalid
        m.node.duration = duration
      end if
    end function

    function setDelay(delay as float)
      m.delay = delay
      if m.node <> invalid
        m.node.delay = delay
      end if
    end function

    function animateTo(toValue as dynamic, duration = invalid as float)

      if m.node.control = "start" or m.node.control = "resume"
        wasPlaying = true
        m.pause()
      else
        wasPlaying = false
      end if

      if duration = invalid
        duration = m.duration
      end if
      m.setDuration(duration)
      m.setFromToValue(m.target[m.field], toValue)
      if wasPlaying = true
        m.start()
      end if
    end function

    ' /**
    '  * @member modifyAnimateTo
    '  * @memberof module:animations.AbstractAnimation
    '  * @instance
    '  * @function
    '  * @description estimates how much time is required to complete the animation given the current delta particularly useful when having to switch destination on the fly.
    '  * @param {any} toValue - the final value
    '  * @param {float} stepSpeed - how long the animation would normally take
    '  * @param {string} stepUnit - "pixel" (100 pixels), "float", 0.1
    '  */
    function animateToWithSpeed(toValue as dynamic, stepSpeed as float, stepUnit = "pixel" as string)
      delta = mv.animations.utils.getDelta(m.target[m.field], toValue)
      if stepUnit = "pixel"
        steps = delta / 100
      else
        steps = delta * 0.1
      end if
      m.animateTo(toValue, steps * stepSpeed)
    end function

    function setFromToValue(fromValue as dynamic, toValue as dynamic)
      if m.isValidValue(toValue) and m.isValidValue(fromValue)
        m.fromValue = fromValue
        m.toValue = toValue
        ' m.log.info("fromValue", fromValue, "toValue", toValue)
        m.interpolator.keyValue = [fromValue, toValue]
      else
        m.log.error("tried to set illegal fromValue or toValue [", fromValue, ",", toValue, "]")
      end if
    end function

    function setkeyValues(keyValues as dynamic)
      if m.isValidValues(keyValues)
        m.keyValues = keyValues
        ' m.log.info("fromValue", fromValue, "toValue", toValue)
        m.interpolator.keyValue = keyValues
      else
        m.log.error("tried to set illegal keyValues")
      end if
    end function

    function setMultiKeys(keys as dynamic)
      'TODO check if it's a float array and legal values
      if mc.isArray(keys)
        m.keys = keys
        ' m.log.info("fromValue", fromValue, "toValue", toValue)
        m.interpolator.keyValue = keys
      else
        m.log.error("tried to set illegal keys")
      end if
    end function

    function jumpToEnd()
      m.stop()
      m.target[m.field] = m.toValue
    end function

    @injectLocalM
    function observeFraction(callback as function, scope = invalid as dynamic)
      mc.tasks.observeNodeField(m.interpolator, "fraction", callback, "value", false, scope)
    end function

    @injectLocalM
    function observeKeyFraction(callback as function, scope = invalid as dynamic)
      mc.tasks.observeNodeField(m.node, "keyFraction", callback, "value", false, scope)
    end function

    function unobserveKeyFraction()
      mc.tasks.cleanNodeObserver(m.node, "keyFraction")
    end function

    @injectLocalM
    function observeKeyIndex(callback as function, scope = invalid as dynamic)
      mc.tasks.observeNodeField(m.node, "keyIndex", callback, "value", false, scope)
    end function

    function unobserveKeyIndex()
      mc.tasks.cleanNodeObserver(m.node, "keyIndex")
    end function

    function enableKeyObservers()
      mc.tasks.observeNodeField(m.interpolator, "fraction", m.onInterpolatorFraction, "value", false, m)
      mc.setOrAddNodeField(m.node, "keyIndex", 0)
      mc.setOrAddNodeField(m.node, "keyFraction", 0.0)
    end function

    function disableKeyObservers()
      mc.tasks.unobserveNodeField(m.interpolator, "fraction", m.onInterpolatorFraction)
      mc.setOrAddNodeField(m.node, "keyIndex", 0)
      mc.setOrAddNodeField(m.node, "keyFraction", 0.0)
    end function

    private function onInterpolatorFraction(fraction as float)
      m.keyFraction = (fraction - m.keyStartFraction) / (m.keyEndFraction - m.keyStartFraction)
      m.node.keyFraction = m.keyFraction
      ' ? " FRACTION " fraction " ( in key " m.keyFraction " ) keyIndex " m.keyIndex

      if m.keyFraction >= 1
        m.moveToNextKey()
      end if
    end function

    function moveToNextKey()
      nextKeyIndex = m.keyIndex + 1
      ' ? " moving to next key " nextKeyIndex " count " m.keys.count() " fraction " m.keyFraction

      if nextKeyIndex < m.keys.count()
        ' ? " SETTING KEY INDEX"
        ' Increment the keyIndex
        m.keyIndex = nextKeyIndex
        m.node.keyIndex = m.keyIndex

        ' ? "MOVE TO KEY INDEX " m.keyIndex
        ' Check if we've reached the end of the keys array

        m.keyStartFraction = m.keys[m.keyIndex]
        m.keyEndFraction = m.keys[m.keyIndex + 1]
      else
        ' ? " REACHED END"
      end if
    end function

    @injectLocalM
    function observeState(callback as function, scope = invalid as dynamic)
      mc.tasks.observeNodeField(m.node, "state", callback, "value", false, scope)
    end function

    function unobserveFraction()
      mc.tasks.cleanNodeObserver(m.interpolator, "fraction")
    end function

    function unobserveState()
      mc.tasks.cleanNodeObserver(m.node, "state")
    end function

    @injectLocalM
    function onFraction(fraction as float, func as function, scope = invalid as dynamic)
      if m.fractionValueObserver = invalid
        if scope = invalid
          scope = mc.getTopM()
        end if
        m.fractionValueObserver = new mc.tasks.ValueObserver(m.interpolator, "fraction", scope)
      end if
      m.fractionValueObserver.onValue(fraction, func, ">=")
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ private impl
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    private function createAnimationNode()
      m.node = createObject("roSGNode", "Animation")
      animId = mv.animations.getAnimationKeyId()
      'bs:disable-next-line
      m.node.id = `${m.target.id}_${m.field}_${animId}`
      m.node.duration = m.duration
      m.node.delay = m.delay
      m.node.easeFunction = m.easeFunction
      m.node.repeat = m.repeat
      m.target.appendChild(m.node)
      m.createInterpolator()
      m.node.appendChild(m.interpolator)
    end function

    protected function createInterpolator()
      m.log.error("createInterpolator must be implemented")
    end function

    protected function _createInterpolator(interpolatorType as string)
      m.interpolator = createObject("roSGNode", interpolatorType)
      animId = mv.animations.getAnimationKeyId()
      'bs:disable-next-line
      m.interpolator.id = `${m.target.id}_i_${m.field}_${animId}`
      m.interpolator.fieldToInterp = `${m.target.id}.${m.field}`
      if m.keys <> invalid and m.keys.count() > 2
        m.setKeys(m.keys, m.keyValues)
      else
        m.setKeys([0, 1], [m.fromValue, m.toValue])
      end if
    end function

  end class

  class Parallel extends mv.animations.AnimationBase
    public animations
    public delay = 0
    public animateFromCurrentValue = false 'if true, the animation will always take the current value, irrespective of from value

    function new(target as mc.types.node, animations = invalid as mc.types.array, repeat = false as boolean, delay = 0 as float)
      super("ParallelAnimation", target)
      m.node = createObject("roSGNode", "ParallelAnimation")
      animId = mv.animations.getAnimationKeyId()
      m.node.delay = delay
      'bs:disable-next-line
      m.node.id = `${m.target.id}_${m.parallel}_${animId}`
      m.setRepeat(repeat)
      if animations <> invalid
        m.addAnimations(animations)
      end if
      m.target.appendChild(m.node)
    end function

    function setAnimateFromCurrentValue(value as dynamic)
      m.animateFromCurrentValue = value
      for each animation in m.animations
        animation.setAnimateFromCurrentValue(value)
      end for
    end function

    override function syncStartKeys()
      for each animation in m.animations
        m.log.debug("setting animation start values for field ", animation.field)
        animation.syncStartKeys()
      end for
    end function

    override function start(resume = false as boolean)
      if m.animateFromCurrentValue
        m.syncStartKeys()
      end if
      super.start(resume)
    end function


    public override function clone()
      animations = []
      for each anim in m.animations
        animations.push(anim.clone())
      end for
      return new mv.animations.Parallel(m.target, animations, m.repeat, m.delay)
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ public api
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    function addAnimations(animations as mc.types.array)
      m.animations = []
      for each animation in animations
        if animation <> invalid and type(animation.node) = "roSGNode"
          animation.parentAnimation = m.node
          if m.delay <> 0
            animation.setDelay(m.delay)
          end if
          m.node.appendChild(animation.node)
          m.animations.push(animation)
        end if
      end for
    end function

    public override function destroy()
      for each animation in m.animations
        animation.destroy()
      end for
    end function

    @injectLocalM
    function observeState(callback as function, scope = invalid as dynamic)
      mc.tasks.observeNodeField(m.node, "state", callback, "value", false, scope)
    end function

    function unobserveState()
      mc.tasks.cleanNodeObserver(m.node, "state")
    end function

    function jumpToEnd()
      for each animation in m.animations
        animation.jumpToEnd()
      end for
    end function
  end class

  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ animation subclasses
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

  class Scale extends mv.animations.AbstractAnimation
    function new(target as mc.types.node, duration as float, fromValue as mc.types.array, toValue as mc.types.array, delay = 0 as float)
      super(target, "scale", duration, fromValue, toValue, "ScaleAnimation", delay)
    end function

    protected override function createInterpolator()
      m._createInterpolator("Vector2DFieldInterpolator")
    end function

    protected override function isValidValue(value as mc.types.array) as boolean
      return mc.isPoint(value)
    end function

    public override function clone()
      return new mv.animations.Scale(m.target, m.duration, m.fromValue, m.toValue, m.delay)
    end function

  end class

  class Fade extends mv.animations.AbstractAnimation
    function new(target as mc.types.node, duration as float, fromValue as float, toValue as float, delay = 0 as float)
      super(target, "opacity", duration, fromValue, toValue, "FadeAnimation", delay)
    end function

    protected override function createInterpolator()
      m._createInterpolator("FloatFieldInterpolator")
    end function

    protected override function isValidValue(value as float) as boolean
      return mc.isNumber(value) and value >= 0 and value <= 1
    end function

    public override function clone()
      return new mv.animations.Fade(m.target, m.duration, m.fromValue, m.toValue, m.delay)
    end function
  end class

  class Color extends mv.animations.AbstractAnimation
    function new(target as mc.types.node, duration as float, fromValue as float, toValue as float, delay = 0 as float)
      super(target, "opacity", duration, fromValue, toValue, "ColorAnimation", delay)
    end function

    protected override function createInterpolator()
      m._createInterpolator("ColorFieldInterpolator")
    end function

    'TODO for now only takes color (int values
    protected override function isValidValue(value as dynamic) as boolean
      return mc.isNumber(value)
    end function

    public override function clone()
      return new mv.animations.Color(m.target, m.duration, m.fromValue, m.toValue, m.delay)
    end function
  end class

  class Move extends mv.animations.AbstractAnimation
    function new(target as mc.types.node, duration as float, fromValue as mc.types.array, toValue as mc.types.array, delay = 0 as float, keys = invalid as mc.types.array)
      super(target, "translation", duration, fromValue, toValue, "MoveAnimation", delay, keys)
    end function

    protected override function createInterpolator()
      m._createInterpolator("Vector2DFieldInterpolator")
    end function

    protected override function isValidValue(value as mc.types.array) as boolean
      return mc.isPoint(value)
    end function

    public override function clone()
      return new mv.animations.Move(m.target, m.duration, m.fromValue, m.toValue, m.delay)
    end function

  end class

  class Size extends mv.animations.AbstractAnimation
    private wAnim as mc.types.node
    private hAnim as mc.types.node
    private pAnim as mc.types.node

    function new(target as mc.types.node, duration as float, fromValue as mc.types.array, toValue as mc.types.array, delay = 0 as float)
      super(target, "size", duration, fromValue, toValue, "SizeAnimation", delay)
      m.wAnim = new mv.animations.FloatValue(target, "width", duration, fromValue[0], toValue[0])
      m.hAnim = new mv.animations.FloatValue(target, "height", duration, fromValue[1], toValue[1])
      m.pAnim = new mv.animations.Parallel(target, [
        m.wAnim,
        m.hAnim
      ])
      m.node = m.pAnim.node

    end function

    public override function clone()
      return new mv.animations.Size(m.target, m.duration, m.fromValue, m.toValue, m.delay)
    end function

    private override function createAnimationNode()
    end function

    override function setEaseFunction(easeFunction as dynamic)
      m.easeFunction = easeFunction
      m.wAnim.setEaseFunction(easeFunction)
      m.hAnim.setEaseFunction(easeFunction)
    end function

    override function setKeys(keys as mc.types.array, keyValues as mc.types.array)
      wKeys = []
      hKeys = []
      for each keyValue in keyValues
        wKeys.push(keyValue[0])
        hKeys.push(keyValue[1])
      end for
      m.wAnim.setKeys(keys, wKeys)
      m.hAnim.setKeys(keys, hKeys)

    end function

    override function setDuration(duration as float)
      m.wAnim.setDuration(duration)
      m.hAnim.setDuration(duration)
      m.duration = duration
    end function

    protected override function isValidValue(value as mc.types.array) as boolean
      return mc.isPoint(value)
    end function

    override function setDelay(delay as float)
      m.delay = delay
      if m.wAnim <> invalid
        m.wAnim.setDelay(delay)
        m.hAnim.setDelay(delay)
      end if
    end function

    override function animateTo(toValue as dynamic, duration = invalid as float)
      m.wAnim.animateTo(toValue[0], duration)
      m.hAnim.animateTo(toValue[1], duration)
    end function

    override function animateToWithSpeed(toValue as dynamic, stepSpeed as float, stepUnit = "pixel" as string)
      m.wAnim.animateToWithSpeed(toValue[0], stepSpeed, stepUnit)
      m.hAnim.animateToWithSpeed(toValue[1], stepSpeed, stepUnit)
    end function

    override function setFromToValue(fromValue as dynamic, toValue as dynamic)
      m.wAnim.setFromToValue(fromValue[0], toValue[0])
      m.hAnim.setFromToValue(fromValue[1], toValue[1])
    end function

    @injectLocalM
    override function observeFraction(callback as function, scope = invalid as dynamic)
      m.wAnim.observeFraction(callback, scope)
    end function

    override function unobserveFraction()
      m.wAnim.unobserveFraction()
    end function
  end class

  class KenBurns extends mv.animations.AbstractAnimation
    private maxScale = 0.0
    private mAnim as mc.types.node
    private sAnim as mc.types.node
    private pAnim as mc.types.node

    function new(target as mc.types.node, duration as float, maxScale as float, delay = 0 as float)
      super(target, "size", duration, invalid, invalid, "SizeAnimation", delay)
      m.maxScale = maxScale
      m.sAnim = mv.animations.utils.scaleTo(target, duration, target.scale, false, delay)
      m.mAnim = mv.animations.utils.moveTo(target, duration, target.translation, false, delay)
      m.pAnim = new mv.animations.Parallel(target, [
        m.sAnim,
        m.mAnim
      ])
      m.node = m.pAnim.node
    end function

    public override function clone()
      return new mv.animations.KenBurns(m.target, m.duration, m.maxScale, m.delay)
    end function

    private override function createAnimationNode()
    end function

    override function setEaseFunction(easeFunction as dynamic)
      m.easeFunction = easeFunction
      m.sAnim.setEaseFunction(easeFunction)
      m.mAnim.setEaseFunction(easeFunction)
    end function

    override function setKeys(keys as mc.types.array, keyValues as mc.types.array)
    end function

    override function setDuration(duration as float)
      m.sAnim.setDuration(duration)
      m.mAnim.setDuration(duration)
      m.duration = duration
    end function

    override function setDelay(delay as float)
      m.delay = delay
      if m.sAnim <> invalid
        m.sAnim.setDelay(delay)
        m.mAnim.setDelay(delay)
      end if
    end function

    override function animateTo(toValue as dynamic, duration = invalid as float)
      m.sAnim.animateTo(toValue[0], duration)
      m.mAnim.animateTo(toValue[1], duration)
    end function

    override function animateToWithSpeed(toValue as dynamic, stepSpeed as float, stepUnit = "pixel" as string)
      m.sAnim.animateToWithSpeed(toValue[0], stepSpeed, stepUnit)
      m.mAnim.animateToWithSpeed(toValue[1], stepSpeed, stepUnit)
    end function

    override function setFromToValue(fromValue as dynamic, toValue as dynamic)
    end function

    @injectLocalM
    override function observeFraction(callback as function, scope = invalid as dynamic)
      m.sAnim.observeFraction(callback, scope)
    end function

    override function unobserveFraction()
      m.sAnim.unobserveFraction()
    end function

    override function jumpToEnd()
      for each animation in [m.sAnim, m.mAnim]
        animation.jumpToEnd()
      end for
    end function

    function ceil(number as float) as integer
      return -int(-number)
    end function

    function floor(number as float) as integer
      return int(number)
    end function

    override function start()
      super.start()
      endScale = mc.clamp(rnd(0) + 1, 1.1, m.maxScale)
      startScale = mc.clamp(rnd(0) + 1, 1.1, m.maxScale)
      fromScale = [
        startScale,
        startScale
      ]
      toScale = [
        endScale,
        endScale
      ]
      m.target.scale = fromScale
      m.sAnim.setFromToValue(fromScale, toScale)
      corners = [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }]

      if m.target.width <> invalid
        w = m.target.width
      else
        w = 1
      end if
      if m.target.height <> invalid
        h = m.target.height
      else
        h = 1
      end if

      sw = w - h * startScale
      sh = h - w * startScale
      xAmount = (rnd(sw) - sw / 2) * 0.25
      yAmount = (rnd(sh) - sh / 2) * 0.25
      'Pick the first corner. Remove it from the array
      choice = m.floor(rnd(3))
      sCorner = corners[choice]
      'Pick the second corner from the subset
      corners.delete(choice)
      eCorner = corners[m.floor(rnd(2))]
      fromPos = [
        sCorner.x * xAmount
        sCorner.y * yAmount
      ]
      sw = w - h * endScale
      sh = h - w * endScale
      xAmount = (rnd(sw) - sw / 2) * 0.25
      yAmount = (rnd(sh) - sh / 2) * 0.25

      toPos = [
        eCorner.x * xAmount
        eCorner.y * yAmount
      ]
      fromPos = [mc.clamp(fromPos[0], -30, 0), mc.clamp(fromPos[1], -30, 0)]
      m.target.translation = fromPos
      m.mAnim.setFromToValue(fromPos, toPos)
    end function
  end class


  class FloatValue extends mv.animations.AbstractAnimation
    function new(target as mc.types.node, field as string, duration as float, fromValue as float, toValue as float, delay = 0 as float)
      super(target, field, duration, fromValue, toValue, "FloatAnimation", delay)
    end function

    protected override function createInterpolator()
      m._createInterpolator("FloatFieldInterpolator")
    end function

    protected override function isValidValue(value as float) as boolean
      return mc.isNumber(value)
    end function

    public override function clone()
      return new mv.animations.FloatValue(m.target, m.duration, m.fromValue, m.toValue, m.delay)
    end function

  end class


  class VectorValue extends mv.animations.AbstractAnimation
    function new(target as mc.types.node, field as string, duration as float, fromValue as mc.types.array, toValue as mc.types.array, delay = 0 as float)
      super(target, field, duration, fromValue, toValue, "VectorValueAnimation", delay)
    end function

    protected override function createInterpolator()
      m._createInterpolator("Vector2DFieldInterpolator")
    end function

    protected override function isValidValue(value as mc.types.array) as boolean
      return mc.isPoint(value)
    end function

    public override function clone()
      return new mv.animations.VectorValue(m.target, m.duration, m.fromValue, m.toValue, m.delay)
    end function

  end class

  'animation type that allows for running an animation, without changing any particular value
  'achieves it by adding a float field to the target node
  class Generic extends mv.animations.AbstractAnimation

    function new(target as mc.types.node, duration as float, delay = 0 as float)
      super(target, "#ga_random", duration, 0, 1, "Generic", delay)
    end function

    protected override function createInterpolator()
      m._createInterpolator("FloatFieldInterpolator")
    end function

    protected override function isValidValue(value as float) as boolean
      return mc.isNumber(value)
    end function

    public override function clone()
      return new mv.animations.Generic(m.target, m.duration, m.delay)
    end function

  end class

  'special animation, which animates multiple views at once, based on view json
  class ViewJson extends mv.animations.AbstractAnimation

    private fromJson as mc.types.assocarray
    private toJson as mc.types.assocarray
    private startMap as mc.types.assocarray
    private toMap as mc.types.assocarray
    private targetM as mc.types.assocarray
    private isObserving = false

    function new(fromJson as mc.types.assocarray, toJson as mc.types.array, duration as float, delay = 0 as float)
      super(mc.getTop(), "#ga_random", duration, 0, 1, "ViewJson", delay)
      m.fromJson = fromJson
      m.toJson = toJson
      m.targetM = mc.getTopM()
    end function

    override function start(resume = false as boolean, useCurrentState = false as boolean)
      if not m.isObserving
        m.observeFraction(m.onViewAnimFraction, m)
        m.isObserving = true
      end if
      if useCurrentState
        m.startMap = mv.getCurrentValuesWithStyleJson(m.toJson)
      else
        m.startMap = mv.getRootValuesWithStyleJson(m.fromJson, m.toJson)
      end if
      m.toMap = mv.getMapFromStyleJson(m.toJson)
      super.start(resume)
    end function

    override function animateTo(toValue as dynamic, duration = invalid as float)
      if m.node.control = "start" or m.node.control = "resume"
        wasPlaying = true
        m.pause()
      else
        wasPlaying = false
      end if

      if duration = invalid
        duration = m.duration
      end if
      m.toJson = toValue
      m.setDuration(duration)

      if wasPlaying = true
        m.start(false, true)
      end if

    end function

    override function animateToWithSpeed(toValue as dynamic, stepSpeed as float, stepUnit = "pixel" as string)
      m.log.error("not supported in ViewJson animation")
    end function

    override function setFromToValue(fromValue as dynamic, toValue as dynamic)
      m.fromJson = fromValue
      m.toJson = toValue
    end function

    protected override function createInterpolator()
      m._createInterpolator("FloatFieldInterpolator")
    end function

    protected override function isValidValue(value as float) as boolean
      return mc.isNumber(value)
    end function

    public override function clone()
      return new mv.animations.Generic(m.target, m.duration, m.delay)
    end function

    private function onViewAnimFraction(fraction as float)
      for each id in m.toMap
        node = m.targetM[id]
        if node <> invalid
          toJson = m.toMap[id]
          fromJson = m.startMap[id]
          if fraction <> invalid
            for each field in toJson
              if field <> "id"
                value = mv.animations.utils.interpolate(fromJson[field], toJson[field], fraction)
                ' ? " SETTING "; field ; " to " ; value ; "f" ; fraction ; " from "; fromJson.field ; " to "; toJson[field]
                node[field] = value
              end if
            end for
          end if
        end if
      end for
    end function

  end class

  class Sequence extends mv.animations.AnimationBase
    public animations
    public delay = 0
    public animateFromCurrentValue = false 'if true, the animation will always take the current value, irrespective of from value

    function new(target as mc.types.node, animations = invalid as mc.types.array, repeat = false as boolean, delay = 0 as float)
      super("SequenceAnimation", target)
      m.node = createObject("roSGNode", "SequentialAnimation")
      animId = mv.animations.getAnimationKeyId()
      'bs:disable-next-line
      m.node.id = `${m.target.id}_${m.sequence}_${animId}`
      m.setRepeat(repeat)
      if animations <> invalid
        m.addAnimations(animations)
      end if
      m.setDelay(delay)
      m.target.appendChild(m.node)
    end function

    function setAnimateFromCurrentValue(value as dynamic)
      m.animateFromCurrentValue = value
      for each animation in m.animations
        animation.setAnimateFromCurrentValue(value)
      end for
    end function

    override function syncStartKeys()
      for each animation in m.animations
        m.log.debug("setting animation start values for field ", animation.field)
        animation.syncStartKeys()
      end for
    end function

    override function start(resume = false as boolean)
      if m.animateFromCurrentValue
        m.syncStartKeys()
      end if

      super.start(resume)
    end function

    public override function clone()
      animations = []
      for each anim in m.animations
        animations.push(anim.clone())
      end for
      return new mv.animations.Sequence(m.target, animations, m.repeat, m.delay)
    end function

    function setDelay(delay as float)
      m.delay = delay
      if m.animations.count() > 0
        m.animations[0].setDelay(delay)
      end if
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ public api
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    function addAnimations(animations as mc.types.array)
      m.animations = []
      for each animation in animations
        if animation <> invalid and type(animation.node) = "roSGNode"
          animation.parentAnimation = m.node
          if m.delay <> 0
            animation.setDelay(m.delay)
          end if
          m.node.appendChild(animation.node)
          m.animations.push(animation)
        end if
      end for
    end function

    public override function destroy()
      for each animation in m.animations
        animation.destroy()
      end for
    end function

    @injectLocalM
    function observeState(callback as function, scope = invalid as dynamic)
      mc.tasks.observeNodeField(m.node, "state", callback, "value", false, scope)
    end function

    function unobserveState()
      mc.tasks.cleanNodeObserver(m.node, "state")
    end function

    function jumpToEnd()
      for each animation in m.animations
        animation.jumpToEnd()
      end for
    end function
  end class

  class SimpleKenBurns extends mv.animations.AbstractAnimation
    private sAnim as mc.types.node
    private mAnim as mc.types.node
    private pAnim as mc.types.node
    private scale = [1, 1]
    private movement = [0, 0]

    function new(target as mc.types.node, duration as float, scale as mc.types.array, movement as mc.types.array, delay = 0 as float)
      super(target, "scale", duration, invalid, invalid, "SimpleKenBurnsAnimation", delay)
      m.scale = [scale, scale]
      m.movement = [target.width * movement[0], target.height * movement[1]]
      m.sAnim = mv.animations.utils.scaleTo(target, duration, m.scale, false, delay)
      m.sAnim.easeFunction = "inQuad"
      m.mAnim = mv.animations.utils.moveTo(target, duration, m.movement, false, delay)
      m.mAnim.easeFunction = "inQuad"
      m.pAnim = new mv.animations.Parallel(target, [
        m.sAnim,
        m.mAnim
      ])
      m.node = m.pAnim.node
    end function

    public override function clone()
      return new mv.animations.SimpleKenBurns(m.target, m.duration, m.scale, m.movement, m.delay)
    end function

    private override function createAnimationNode()
    end function

    override function setEaseFunction(easeFunction as dynamic)
      m.easeFunction = easeFunction
      m.sAnim.setEaseFunction(easeFunction)
      m.mAnim.setEaseFunction(easeFunction)
    end function

    override function setKeys(keys as mc.types.array, keyValues as mc.types.array)
    end function

    override function setDuration(duration as float)
      m.sAnim.setDuration(duration)
      m.mAnim.setDuration(duration)
      m.duration = duration
    end function

    override function setDelay(delay as float)
      m.delay = delay
      if m.sAnim <> invalid
        m.sAnim.setDelay(delay)
        m.mAnim.setDelay(delay)
      end if
    end function

    override function animateTo(toValue as dynamic, duration = invalid as float)
      m.log.error("not supported")
    end function

    override function animateToWithSpeed(toValue as dynamic, stepSpeed as float, stepUnit = "pixel" as string)
      m.log.error("not supported")
    end function

    override function setFromToValue(fromValue as dynamic, toValue as dynamic)
      m.log.error("not supported")
    end function

    @injectLocalM
    override function observeFraction(callback as function, scope = invalid as dynamic)
      m.sAnim.observeFraction(callback, scope)
    end function

    override function unobserveFraction()
      m.sAnim.unobserveFraction()
    end function

    override function jumpToEnd()
      for each animation in [m.sAnim, m.mAnim]
        animation.jumpToEnd()
      end for
    end function

  end class
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  '++ private utils
  '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


  function getAnimationKeyId()
    if m.global.__m_animKey = invalid
      m.global.addFields({ __m_animKey: 0 })
    end if
    m.global.__m_animKey++
    return m.global.__m_animKey
  end function
end namespace
